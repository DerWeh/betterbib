#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
'''
Parses a number of bibitems into a proper BibTeX bibliography.  Since bibitems
don't have semantic information, certain heuristics have to be applied.
'''

import argparse
import re


def _main():
    '''Extra
    '''
    args = _parse_args()
    bibitem_strings = extract_bibitems(args.input)
    previous_author = None
    for bibitem_string in bibitem_strings:
        bibitem = parse_bibitem_string(bibitem_string)
        # If the author entry contains a vrule, assume that this is a
        # placeholder for the authors from the previous paper.
        if (
           'authors' in bibitem and
           ('\\vrule' in bibitem['authors'] or
            '\\sameauthor' in bibitem['authors']
            ) and
           previous_author
           ):
            bibitem['authors'] = previous_author
        entry = create_bibtex_string(bibitem)
        print(entry)
        if 'authors' in bibitem:
            previous_author = bibitem['authors']
        else:
            previous_author = None
    return


def clean(entry):
    '''Removes newlines and font specs from entries.
    '''
    new = entry
    new = entry \
        .replace('\n', ' ') \
        .replace('\\em ', '') \
        .replace('\\sc ', '') \
        .replace('~', ' ') \
        .strip()
    # Remove surrounding brackets
    if new[0] == '{' and new[-1] == '}':
        new = new[1:-1].strip()

    # Replace multiple white space by a simple space.
    new = re.sub('\s+', ' ', new)
    return new


def clean_pages(entry):
    new = clean(entry)
    m = re.match('^[^0-9]*([0-9]+[-]+[0-9]+).*', entry)
    if m and len(m.groups()) > 0:
        new = m.group(1) \
            .replace('--', '-')
    return new


def create_bibtex_string(bibitem):
    entries = []
    if 'authors' in bibitem:
        entries.append('  author = {%s}' % clean(bibitem['authors']))
    if 'title' in bibitem:
        entries.append('  title = {%s}' % clean(bibitem['title']))
    if 'journal' in bibitem:
        entries.append('  journal = {%s}' % clean(bibitem['journal']))
    if 'publisher' in bibitem:
        entries.append('  publisher = {%s}' % clean(bibitem['publisher']))
    if 'pages' in bibitem:
        entries.append('  pages = {%s}' % clean_pages(bibitem['pages']))
        entry_type = 'article'
    else:
        entry_type = 'book'
    if 'year' in bibitem:
        entries.append('  year = {%s}' % clean_pages(bibitem['year']))

    entry = '@%s{%s,\n%s\n}' \
        % (entry_type, bibitem['key'], ',\n'.join(entries))
    return entry


def my_split(s):
    '''Explodes a string around commas except when in a {}-environment.
    See <http://stackoverflow.com/a/26809037/353337>.
    '''
    parts = []
    bracket_level = 0
    current = []
    # trick to remove special-case of trailing chars
    for c in (s + ','):
        if c == ',' and bracket_level == 0:
            parts.append(''.join(current))
            current = []
        else:
            if c == '{':
                bracket_level += 1
            elif c == '}':
                bracket_level -= 1
            current.append(c)
    return parts


def parse_bibitem_string(bibitem_string):
    '''Parses a bibitem given as (multiline) string and returns semantic
    information. Of course, heuristics are needed.
    '''
    # Extract the reference key
    re.DOTALL
    regex = re.compile('^\\\\bibitem{(\w+)}\s*(.*)', re.DOTALL)
    m = re.match(regex, bibitem_string)

    # Explode the rest of the string around commas, except the commas
    # are enclosed in curly brackets (e.g., in the authors list).
    m2 = my_split(m.group(2))

    # Now the heuristics.
    bibitem = {
        'key': m.group(1).strip(),
        'authors': clean_bibitem_string(m2[0]),
        'title': clean_bibitem_string(m2[1]),
        }

    is_journal = True
    if len(m2) > 4:
        a = clean_bibitem_string(m2[4])
        if a[-1] == '.':
            a = a[:-1]

        if len(a) == 4 and '-' not in a:
            bibitem['year'] = a
            is_journal = False
        else:
            bibitem['pages'] = a

    if len(m2) > 2:
        if is_journal:
            bibitem['journal'] = clean_bibitem_string(m2[2])
        else:
            bibitem['publisher'] = clean_bibitem_string(m2[2])

    if len(m2) > 3:
        bibitem['number'] = clean_bibitem_string(m2[3])

    return bibitem


def clean_bibitem_string(string):
    '''Removes surrounding whitespace, surrounding \emph brackets etc.
    '''
    out = string
    out = out.strip()
    if out[:6] == '\\emph{' and out[-1] == '}':
        out = out[6:-1]
    if out[:8] == '\\textsc{' and out[-1] == '}':
        out = out[8:-1]

    return out


def extract_bibitems(filename):
    '''Parses `filename` and returns all bibitems from inside all
    `thebibliography` environments.
    '''
    recording = False
    bibitems = []
    with open(filename, 'r') as f:
        for line in f:
            # Get first non-whitespace character
            m = re.match('^\s*(\S)', line)
            # Skip commented-out lines
            if m and m.group(1) == '%':
                continue
            if '\\begin{thebibliography}' in line:
                recording = True
            if '\\end{thebibliography}' in line:
                recording = False

            if recording:
                if '\\bibitem' in line:
                    # Create new bibitem entry
                    bibitems.append(line)
                elif len(bibitems) > 0:
                    # Append to last bibitem entry
                    bibitems[-1] += line
    return bibitems


def _parse_args():
    parser = argparse.ArgumentParser(description='Extract bibitems.')
    parser.add_argument(
        'input',
        type=str,
        help='input LaTeX file'
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
