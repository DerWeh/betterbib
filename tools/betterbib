#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
from __future__ import print_function, unicode_literals

import argparse
import collections
from io import open as io_open
from requests_futures.sessions import FuturesSession
import sys

# pylint: disable=import-self
import betterbib
from betterbib import pybtex_to_bibtex_string

from pybtex.database.input import bibtex
from tqdm import tqdm


# pylint: disable=too-many-locals
def _main():
    args = _parse_cmd_arguments()
    infile = args.infile

    parser = bibtex.Parser()
    data = parser.parse_file(infile)

    n = len(data.entries)

    print('Reading from: {}'.format(infile))
    print('Saving to: {}\n'.format(args.outfile))

    # Open output file for writing.
    out = io_open(args.outfile, mode='w', encoding='utf-8')

    # Write header to the output file.
    out.write(
        '%%comment{This file was created with betterbib v%s.}\n\n' %
        betterbib.__version__
        )

    # Use an ordered dictionary to make sure that the entries are written out
    # sorted by their BibTeX key if
    od = (
        collections.OrderedDict(sorted(data.entries.items()))
        if args.sort_by_bibkey
        else data.entries
        )

    num_success = 0

    source = betterbib.Crossref(args.long_journal_name)

    # def find_unique(self, entry):
    #     params = self.prepare_request_params(entry)

    #     response = requests.get(self.api_url, params=params)
    #     if not response.ok:
    #         raise HttpError('Failed request to {}'.format(self.api_url))

    #     return self.extract_unique(entry, response)

    print('Prepare requests')
    params = []
    for entry in tqdm(od.values()):
        params += [source.prepare_request_params(entry)]

    print
    print('HTTPS requests')
    with FuturesSession(max_workers=20) as session:
        futures = [
            session.get(source.api_url, params=p)
            for p in params
            ]
        responses = []
        for f in tqdm(futures):
            responses += [f.result()]

    exit(1)

    # for bib_id, entry in tqdm(od.items()):
    #     result = None

    #     try:
    #         result = source.find_unique(entry)
    #     except (betterbib.crossref.NotFoundError,
    #             betterbib.crossref.UniqueError):
    #         pass
    #     except betterbib.crossref.HttpError as e:
    #         print(e.args[0])
    #     else:
    #         num_success += 1

    #     d = betterbib.bibtex.sanitize_doi_url(result if result else entry)

    #     a = pybtex_to_bibtex_string(
    #         d, bib_id, bracket_delimeters=not args.quote_delimeters
    #         )

    #     if not result:
    #         out.write(
    #             '%comment{Error when fetching the following entry.}\n'
    #             )

    #     out.write(a + '\n\n')

    out.close()
    print('\n\nTotal number of entries: {}'.format(n))
    print('Found: {}'.format(num_success))

    return


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(
        description='Improve BibTeX libraries '
        'with information from online sources.'
        )
    parser.add_argument(
        'infile',
        type=str,
        help='input BibTeX file'
        )
    parser.add_argument(
        'outfile',
        type=str,
        help='output BibTeX file'
        )
    parser.add_argument(
        '--long-journal-name', '-l',
        action='store_true',
        help='prefer long journal names (default: false)'
        )
    parser.add_argument(
        '--quote-delimeters', '-d',
        action='store_true',
        help='use quote delimeters in output file (default: curly brackets)',
        )
    parser.add_argument(
        '--sort-by-bibkey', '-s',
        action='store_true',
        help='sort entries by BibTeX key (default: false)'
        )
    parser.add_argument(
        '--version', '-v',
        help='display version information',
        action='version',
        version='%(prog)s {}, Python {}'.format(
            betterbib.__version__, sys.version
            )
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
