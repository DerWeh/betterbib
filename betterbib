#!/usr/bin/env python
# -*- coding: utf8 -*-
#
#   BetterBib updates a BibTeX file with information from MathSciNet.
#   Copyright (C) 2013--2014  Nico Schlömer
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see [http://www.gnu.org/licenses/].
#
import re
import xml.etree.ElementTree
import sys
import os
import time
import requests
import collections
from pybtex.database.input import bibtex

NAME = 'BetterBib'
VERSION = '0.1.0'
COPYRIGHT_YEARS = '2013--2014'
AUTHOR = 'Nico Schlömer'
AUTHOR_EMAIL = 'nico.schloemer@gmail.com'
WEBSITE = 'https://github.com/nschloe/betterbib'


class Checker(object):
    '''
    Abstract base class for all BibTeX checkers.
    '''
    def find(self, bibtex_entry):
        raise NotImplementedError


class MathSciNet(Checker):
    '''
    BibTeX resource from MathSciNet, http://www.ams.org/mathscinet/.
    Unfortunately, access to MathSciNet is restricted and typically only
    accessible from university campuses.
    '''
    def __init__(self):
        servers = ['http://www.ams.org/mathscinet/',
                   'http://ams.rice.edu/mathscinet/',
                   'http://ams.impa.br/mathscinet/',
                   'http://ams.math.uni-bielefeld.de/mathscinet/',
                   'http://ams.mpim-bonn.mpg.de/mathscinet/',
                   'http://ams.u-strasbg.fr/mathscinet/'
                   ]

        self.server = servers[0]

        sys.stdout.write('Checking connection with %s... ' % self.server)
        try:
            t = time.time()
            self._test_connection()
            elapsed = time.time() - t
            sys.stdout.write('ok (%gs).\n\n' % elapsed)
        except:
            sys.stdout.write('failed.\n\n')
            message = ('Unable to establish connection with %s. '
                       'Make sure that you have access to the site and that'
                       'the search function returns valid results.\n\n') \
            % self.server
            sys.stdout.write(message)
            raise
        return

    def _test_connection(self):
        '''Test the connection with MathSkyNet. ;)
        '''
        test_entry = {'title': 'Krylov subspace methods',
                      'author': 'Liesen and Strakoš'
                      }

        # Define the expected return string. Note that special characters need
        # to be escaped.
        expected = '''@book {MR3024841,
    AUTHOR = {Liesen, J{\\"o}rg and Strako{\\v{s}}, Zden{\\v{e}}k},
     TITLE = {Krylov subspace methods},
    SERIES = {Numerical Mathematics and Scientific Computation},
      NOTE = {Principles and analysis},
 PUBLISHER = {Oxford University Press, Oxford},
      YEAR = {2013},
     PAGES = {xvi+391},
      ISBN = {978-0-19-965541-0},
   MRCLASS = {65F10 (65F15)},
  MRNUMBER = {3024841},
MRREVIEWER = {Melina A. Freitag},
}'''
        bt = self.find(test_entry)
        # Check the result.
        if bt != expected:
            import difflib
            diff = difflib.Differ().compare(bt, expected)
            diff = ''.join(['***' + i[2:] + '***' if i[:1] == '+'
                else i[2:] for i in diff if not i[:1] in '-?'])
            print
            print(diff)
            print
            raise RuntimeError(
                'Connection established, but wrong search result.'
                )
        return

    def find(self, entry):
        url = self.server + '/search/publications.html'

        # Typical search query line:
        # http://www.ams.org/MathSciNet/search/publications.html?pg4=AUCN&s4=&co4=AND&pg5=TI&s5=ggg&co5=AND&pg6=PC&s6=&co6=AND&pg7=ALLF&s7=&co7=AND&Submit=Search&dr=all&yrop=eq&arg3=&yearRangeFirst=&yearRangeSecond=&pg8=ET&s8=All&review_format=html
        #
        # Specify the search criteria.
        # The loop below will first search for title only, then title and author,
        # and so forth, until a unique match is found.
        #
        search_criteria = ['title', 'author', 'year', 'journal']
        success = False
        # default (empty) payload
        payload = {'pg4': 'AUCN', 's4': '', 'co4': 'AND',
                   'pg5': 'TI',   's5': '', 'co5': 'AND',
                   'pg6': 'PC',   's6': '', 'co6': 'AND',
                   'pg7': 'ALLF', 's7': '', 'co7': 'AND',
                   'Submit': 'Search',
                   'dr': 'all',
                   'yrop': 'eq',
                   'arg3': '',
                   'yearRangeFirst': '',
                   'yearRangeSecond': '',
                   'pg8': 'ET',
                   's8': 'All',
                   'review_format': 'html',
                   'fmt': 'bibtex'  # immediately jump to BibTeX
                   }
        for sc in search_criteria:
            # Add a search criterion.
            if sc == 'title':
                try:
                    title = entry['title']
                except:
                    continue
                # Remove everything starting from the first dollar sign (math
                # mode). Removing only what is enclosed in the dollar signs does
                # not work with MathSciNet's search mask, unfortunately.
                p = '\$.*'
                title = re.sub(p, '', title)
                # Remove some tokens that make MathSciNet fail.
                title = title.replace('{', '')
                title = title.replace('}', '')
                title = title.replace('(', '')
                title = title.replace(')', '')
                # Replacing some common TeX symbols.
                title = title.replace('\\"a', u'ä')
                title = title.replace('\\"o', u'ö')
                title = title.replace('\\"u', u'ü')
                title = title.replace('\\"A', u'Ä')
                title = title.replace('\\"O', u'Ö')
                title = title.replace('\\"U', u'Ü')
                payload['pg4'] = 'TI'
                payload['s4'] = title
            elif sc == 'author':
                try:
                    authors = entry['author'].split(' and ')
                    last_names = []
                    for author in authors:
                        # Extract everything up to the first comma of `author`
                        # which is hopefully the last name.
                        last_names.append(re.sub('([^,]+),.*', r'\1', author))
                except:
                    continue
                last_names = ' and '.join(last_names)
                payload['pg5'] = 'AUCN'
                payload['s5'] = last_names
            elif sc == 'year':
                payload['dr'] = 'pubyear'
                try:
                    payload['arg3'] = entry['year']
                except:
                    continue
            elif sc == 'journal':
                payload['pg6'] = 'JOUR'
                try:
                    payload['s6'] = entry['journal']
                except:
                    continue
            else:
                ValueError('Illegal search criterion \'%s\'.' % sc)

            # Search request.
            r = requests.get(url, params=payload)
            if not r.ok:
                raise RuntimeError('Could not fetch data (status code %d).'
                                   % r.status_code)

            # Find the BibTeX entry and extract it.
            a = '@[a-zA-Z]+\s*{'
            m = re.findall(a, r.content)
            if len(m) == 1:
                success = True
                break
            elif len(m) == 0:
                # Check if the website issues an error message.
                a = 'No publications results for'
                m = re.search(a, r.content)
                if m:
                    raise RuntimeError('No publication results on MathSciNet.')
                else:
                    raise RuntimeError('Unknown error on MathSciNet.')
            # else len(m) > 1 .. try again with stricter criteria

        if not success:
            raise RuntimeError('Found %d matches with full criteria.' % len(m))

        # Now we know that there is exactly one matching entry in the string.
        # If there's a way to extract the corresponding MatchObject directly
        # from findall, that'd be great. For now, just to another search().
        m = re.search(a, r.content)

        # Find matching closing bracket.
        i0 = m.end()
        num_open_brackets = 1
        i1 = i0
        while num_open_brackets > 0:
            if r.content[i1] == '{':
                num_open_brackets += 1
            elif r.content[i1] == '}':
                num_open_brackets -= 1
            i1 += 1
        bibtex_entry = r.content[m.start():i1]

        return bibtex_entry


def _main():
    args = _parse_cmd_arguments()
    infile = args.infile

    sys.stdout.write('Reading from: %s\n' % infile)

    data = _read_bibtex(infile)
    n = len(data.entries)

    sys.stdout.write('Number of entries: %d\n' % n)
    sys.stdout.write('Saving to: %s\n' % args.outfile)
    sys.stdout.write('\n')

    # Create the checkers.
    mathscinet = MathSciNet()

    # Open output file for writing.
    out = open(args.outfile, 'w')

    # Write header to the output file.
    out.write(('@comment{\n'
               'This file was created by %s v%s.\n'
               'Copyright (c) %s, %s <%s>\n'
               'All rights reserved.\n'
               '\n'
               'The latest updates can be retrieved from\n'
               '    <%s>\n'
               'where you can also file issues and contribute to %s.\n'
               '}\n'
               )
              % (NAME, VERSION, COPYRIGHT_YEARS, AUTHOR, AUTHOR_EMAIL,
                 WEBSITE, NAME))

    # Determine progress bar width according to the current console width.
    rows, columns = os.popen('stty size', 'r').read().split()
    progress_bar_width = int(columns) - 10 - len(str(n))

    # Use an ordered dictionary to make sure that the entries are written out
    # sorted by their BibTeX key.
    od = collections.OrderedDict(sorted(data.entries.items()))

    k = 0
    success_count = 0
    for bib_id, entry in od.iteritems():
        k += 1
        b = entry.fields

        # Print a progress bar.
        # 73% [==========================>          ] 143
        percentage = float(k) / n
        filled_width = int(percentage * progress_bar_width)
        empty_width = progress_bar_width - filled_width
        sys.stdout.write(('\r%3d%% [' + '=' * (filled_width - 1) + '>'
                         + ' ' * empty_width + '] %d')
                         % (int(100 * percentage), k)
                         )
        sys.stdout.flush()

        # Clean up the title string.
        try:
            bibtex_entry = mathscinet.find(b)
        except RuntimeError as e:
            #print('Entry not found (\'%s\').' % e.message)
            # Write out the old entry to file.
            a = _get_string_representation(entry)
            out.write('@comment{Error when fetching the following entry (%s).}\n' % e.message)
            # This write operation may fail if `a` contains non-ASCII
            # characters. It's okay to fail too since this case requires some
            # human interaction anyways.
            try:
                out.write(a.encode('utf8'))
            except:
                #print('\nUnable to write the following entry to an '
                #      'ASCII-encoded file:\n\n %s\n' % a
                #      )
                raise
        else:
            #print('found.')
            # Make sure that the BibTeX key remains identical.
            pattern = '(@[a-zA-Z]+)\s*{\w+'
            bibtex_entry = re.sub(pattern, r'\1{%s' % bib_id, bibtex_entry)
            # Write it out to a file.
            out.write(bibtex_entry)
            success_count += 1
        out.write('\n\n')

    out.close()
    print
    print('%d of %d entries successfully converted.' % (success_count, n))
    return


def _get_string_representation(entry):
    '''String representation of BibTeX entry.
    '''
    lst = []
    lst.append('@%s{%s' % (entry.type, entry.key))
    for key, persons in entry.persons.items():
        persons_str = ' and '.join([_get_person_str(p) for p in persons])
        lst.append('%s = {%s}' % (key, persons_str))
    for field, value in entry.fields.iteritems():
        lst.append('%s = {%s}' % (field, value))
    lst.append('}')
    return ',\n  '.join(lst)


def _get_person_str(p):
    person_str = []
    for s in [' '.join(p.prelast() + p.last()),
              ' '.join(p.lineage()),
              ' '.join(p.first() + p.middle())]:
        if s:
            person_str.append(s)
    return ', '.join(person_str)


def _read_bibtex(filename):
    # Open file for parsing.
    parser = bibtex.Parser()
    data = parser.parse_file(filename)
    return data


def _parse_cmd_arguments():
    import argparse
    parser = argparse.ArgumentParser(
        description='Improve BibTeX libraries '
        'with information from online sources.'
        )
    parser.add_argument('infile',
                        type=str,
                        help='input BibTeX file')
    parser.add_argument('outfile',
                        type=str,
                        help='output BibTeX file')
    return parser.parse_args()


def _get_maps():
    tree = xml.etree.ElementTree.parse('unicode.xml')
    root = tree.getroot()

    u2l = {}
    l2u = {}
    for char in root.iter('character'):
        try:
            uni = unichr(int(char.attrib['dec'])).encode('utf-8')
            for sub in char.iter('latex'):
                lat = sub.text
                u2l[uni] = lat
                l2u[lat] = uni
        except ValueError:
            pass
    return u2l, l2u


def _preprocess_latex(s):
    # list: https://en.wikibooks.org/wiki/LaTeX/Special_Characters
    return re.sub(r'\\([\'"`\^\~=\.])([a-zA-Z])',
                  r'\\\1{\2}',
                  s)


if __name__ == '__main__':
    _main()
