#!/usr/bin/env python
# -*- coding: utf8 -*-
#
#   bibtex-mathscinet updates a BibTeX file with information from mathscinet.
#   Copyright (C) 2013  Nico Schlömer
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see [http://www.gnu.org/licenses/].
#
import re
import xml.etree.ElementTree as ET
# -----------------------------------------------------------------------------
def _main():

    args = _parse_cmd_arguments()
    infile = args.infile

    data = _read_bibtex(infile)

    # Open output file for writing.
    out = open(args.outfile, 'w')

    n = len(data.entries)
    k = 0
    success_count = 0
    for bib_id in data.entry_keys:
        k += 1
        b = data.entries[bib_id].fields
        # Clean up the title string.
        print('Searching for entry %d/%d...' % (k, n))
        try:
            bibtex_entry = _find_on_mathscinet(b)
        except RuntimeError as e:
            print('Entry not found (\'%s\').' % e.message)
            # Write out the old entry to file.
            a = _get_string_representation(data.entries[bib_id])
            print(a)
            out.write('# Error when fetching the following entry from mathscinet (%s).\n' % e.message)
            out.write(a)
        else:
            print('found.')
            # Make sure that the BibTeX key remains identical.
            pattern = '(@[a-zA-Z]+)\s*{\w+'
            bibtex_entry = re.sub(pattern, r'\1{%s' % bib_id, bibtex_entry)
            # Write it out to a file.
            out.write(bibtex_entry)
            success_count += 1
        out.write('\n\n')

    out.close()
    print('%d out of %d entries successfully converted.' % (success_count, n))

    return
# -----------------------------------------------------------------------------
def _get_string_representation(entry):
    '''String representation of BibTeX entry.
    '''
    lst = []
    lst.append('@%s{%s' % (entry.type, entry.key))
    for key, persons in entry.persons.items():
        persons_str = ' and '.join([_get_person_str(p) for p in persons])
        lst.append('%s = {%s}' % (key, persons_str))
    for field, value in entry.fields.iteritems():
        lst.append('%s = {%s}' % (field, value))
    lst.append('}')

    return ',\n  '.join(lst)
# -----------------------------------------------------------------------------
def _get_person_str(p):
    person_str = []
    for s in [' '.join(p.prelast()+p.last()),
            ' '.join(p.lineage()),
            ' '.join(p.first()+p.middle())]:
        if s:
            person_str.append(s)
    return ', '.join(person_str)
# -----------------------------------------------------------------------------
def _read_bibtex(filename):

    from pybtex.database.input import bibtex

    # Open file for parsing.
    parser = bibtex.Parser()
    data = parser.parse_file(filename)

    return data
# -----------------------------------------------------------------------------
def _find_on_mathscinet(entry):
    import requests

    #url = 'http://www.ams.org/mathscinet/search/publications.html'
    url = 'http://ams.math.uni-bielefeld.de/mathscinet/search/publications.html'

    # Typical search query line:
    # http://www.ams.org/mathscinet/search/publications.html?pg4=AUCN&s4=&co4=AND&pg5=TI&s5=ggg&co5=AND&pg6=PC&s6=&co6=AND&pg7=ALLF&s7=&co7=AND&Submit=Search&dr=all&yrop=eq&arg3=&yearRangeFirst=&yearRangeSecond=&pg8=ET&s8=All&review_format=html
    #
    # Specify the search criteria.
    # The loop below will first search for title only, then title and author,
    # and so forth, until a unique match is found.
    #
    search_criteria = ['title', 'author', 'year', 'journal']
    success = False
    # default (empty) payload
    payload = {'pg4': 'AUCN', 's4': '', 'co4': 'AND',
               'pg5': 'TI',   's5': '', 'co5': 'AND',
               'pg6': 'PC',   's6': '', 'co6': 'AND',
               'pg7': 'ALLF', 's7': '', 'co7': 'AND',
               'Submit': 'Search',
               'dr': 'all',
               'yrop': 'eq',
               'arg3': '',
               'yearRangeFirst': '',
               'yearRangeSecond': '',
               'pg8': 'ET',
               's8': 'All',
               'review_format': 'html',
               'fmt': 'bibtex' # immediately jump to BibTeX
               }
    for sc in search_criteria:
        # Add a search criterion.
        if sc == 'title':
            try:
                title = entry['title']
            except:
                continue
            # Remove everything starting from the first dollar sign (math
            # mode). Removing only what is enclosed in the dollar signs does
            # not work with matscinet's search mask, unfortunately.
            p = '\$.*'
            import re
            title = re.sub(p, '', title)
            # Remove some tokens that make mathscinet fail.
            title = title.replace('{', '')
            title = title.replace('}', '')
            title = title.replace('(', '')
            title = title.replace(')', '')
            # Replacing some common TeX symbols.
            title = title.replace('\\"a', u'ä')
            title = title.replace('\\"o', u'ö')
            title = title.replace('\\"u', u'ü')
            title = title.replace('\\"A', u'Ä')
            title = title.replace('\\"O', u'Ö')
            title = title.replace('\\"U', u'Ü')
            payload['pg4'] = 'TI'
            payload['s4'] = title
        elif sc == 'author':
            authors = entry['author'].split(' and ')
            try:
                author_lastname = re.sub('([^,]+),.*', r'\1', authors[0])
            except:
                continue
            payload['pg5'] = 'AUCN'
            payload['s5'] = author_lastname
            # If there is more than one author, include it too.
            if len(authors) > 1:
                try:
                    author_lastname = re.sub('([^,]+),.*', r'\1', authors[1])
                except:
                    continue
                payload['pg6'] = 'AUCN'
                payload['s6'] = author_lastname
        elif sc == 'year':
            payload['dr'] = 'pubyear'
            try:
                payload['arg3'] = entry['year']
            except:
                continue
        elif sc == 'journal':
            payload['pg7'] = 'JOUR'
            try:
                payload['s7'] = entry['journal']
            except:
                continue
        else:
            ValueError('Illegal search criterion \'%s\'.' % sc)

        # Search request.
        r = requests.get(url, params=payload)
        if not r.ok:
            raise RuntimeError('Could not fetch data.')

        # Find the BibTeX entry and extract it.
        import re
        a = '@[a-zA-Z]+\s*{'
        m = re.findall(a, r.content)
        if len(m) == 1:
            success = True
            break
        elif len(m) == 0:
            # Check if the website issues an error message.
            a = 'No publications results for'
            m = re.search(a, r.content)
            if m:
                raise RuntimeError('No publication results on mathscinet.')
            else:
                raise RuntimeError('Unknown error on mathscinet.')
        # else len(m) > 1 .. try again with stricter criteria

    if not success:
        raise RuntimeError('Found %d matches with full criteria.' % len(m))

    # Now we know that there is exactly one matching entry in the string.
    # If there's a way to extract the corresponding MatchObject directly
    # from findall, that'd be great. For now, just to another search().
    m = re.search(a, r.content)

    # Find matching closing bracket.
    i0 = m.end()
    num_open_brackets = 1
    i1 = i0
    while num_open_brackets > 0:
        if r.content[i1] == '{':
            num_open_brackets += 1
        elif r.content[i1] == '}':
            num_open_brackets -= 1
        i1 += 1
    bibtex_entry = r.content[m.start():i1]

    return bibtex_entry
# -----------------------------------------------------------------------------
def _parse_cmd_arguments():
    import argparse

    parser = argparse.ArgumentParser(description='Improve BibTeX libraries.')
    parser.add_argument('infile',
                        type=str,
                        help='input BibTeX file')
    parser.add_argument('outfile',
                        type=str,
                        help='output BibTeX file')

    return parser.parse_args()
# -----------------------------------------------------------------------------
def _get_maps():
    tree = ET.parse('unicode.xml');
    root = tree.getroot()

    u2l = {}
    l2u = {}
    for char in root.iter('character'):
        try:
            uni = unichr(int(char.attrib['dec'])).encode('utf-8')
            for sub in char.iter('latex'):
                lat = sub.text
                u2l[uni] = lat
                l2u[lat] = uni
        except ValueError as e:
            pass
    return u2l, l2u
# -----------------------------------------------------------------------------
def _preprocess_latex(s):
    # list: https://en.wikibooks.org/wiki/LaTeX/Special_Characters
    return re.sub(r'\\([\'"`\^\~=\.])([a-zA-Z])',
                  r'\\\1{\2}',
                  s)
# -----------------------------------------------------------------------------
if __name__ == '__main__':
    _main()
# -----------------------------------------------------------------------------
